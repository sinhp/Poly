/-
Copyright (c) 2024 Sina Hazratpour. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Sina Hazratpour, Wojciech Nawrocki
-/

import Poly.ForMathlib.CategoryTheory.LocallyCartesianClosed.BeckChevalley -- LCCC.BeckChevalley
import Mathlib.CategoryTheory.Functor.TwoSquare
import Poly.ForMathlib.CategoryTheory.PartialProduct
import Poly.ForMathlib.CategoryTheory.NatTrans


/-!
# Polynomial Functor

The Universal property of polynomial functors is mediated through the partial product diagram
in below.
```
     X
     ^
     |
     |
     ‚Ä¢ -------fst-----> P @ X
     |                    |
     |        (pb)        | P.fstProj X
     v                    v
     E ---------------->  B
              P.p
```
-- TODO: there are various `sorry`-carrying proofs in below which require instances of
`ExponentiableMorphism` for various constructions on morphisms. They need to be defined in
`Poly.Exponentiable`.
-/

noncomputable section

namespace CategoryTheory

open CategoryTheory Category Limits Functor Adjunction Over ExponentiableMorphism
  LocallyCartesianClosed

variable {C : Type*} [Category C] [HasPullbacks C]

/-- `P : UvPoly C` is a polynomial functors in a single variable -/
structure UvPoly (E B : C) where
  (p : E ‚ü∂ B)
  (exp : ExponentiableMorphism p := by infer_instance)

attribute [instance] UvPoly.exp

namespace UvPoly

open TwoSquare

variable [HasTerminal C]

instance : HasBinaryProducts C :=
  hasBinaryProducts_of_hasTerminal_and_pullbacks C

variable {E B : C}

/-- The constant polynomial in many variables: for this we need the initial object -/
def const [HasInitial C] (S : C) : UvPoly (‚ä•_ C) S := ‚ü®initial.to S, sorry‚ü©

def smul (S : C) (P : UvPoly E B) : UvPoly (S ‚®Ø E) (S ‚®Ø B) :=
  ‚ü®prod.map (ùüô S) P.p, sorry‚ü©

/-- The product of two polynomials in a single variable. -/
def prod {E' B'} (P : UvPoly E B) (Q : UvPoly E' B') [HasBinaryCoproducts C] :
    UvPoly ((E ‚®Ø B') ‚®ø (B ‚®Ø E')) (B ‚®Ø B') where
  p := coprod.desc (prod.map P.p (ùüô B')) (prod.map (ùüô B) Q.p)
  exp := sorry -- perhaps we need extra assumptions on `C` to prove this, e.g. `C` is lextensive?

/-- For a category `C` with binary products, `P.functor : C ‚•§ C` is the functor associated
to a single variable polynomial `P : UvPoly E B`. -/
def functor (P : UvPoly E B) : C ‚•§ C :=
  star E ‚ãô pushforward P.p ‚ãô forget B

/-- The evaluation function of a polynomial `P` at an object `X`. -/
def apply (P : UvPoly E B) : C ‚Üí C := (P.functor).obj

@[inherit_doc]
infix:90 " @ " => UvPoly.apply

instance (P : UvPoly E B) : Limits.PreservesLimitsOfShape WalkingCospan P.functor := by
  unfold functor
  infer_instance

variable (B)

/-- The identity polynomial functor in single variable. -/
@[simps!]
def id : UvPoly B B := ‚ü®ùüô B, by infer_instance‚ü©

/-- The functor associated to the identity polynomial is isomorphic to the identity functor. -/
def idIso : (UvPoly.id B).functor ‚âÖ star B ‚ãô forget B :=
  isoWhiskerRight (isoWhiskerLeft _ (pushforwardIdIso B)) (forget B)

/-- Evaluating the identity polynomial at an object `X` is isomorphic to `B √ó X`. -/
def idApplyIso (X : C) : (id B) @ X ‚âÖ B ‚®Ø X := sorry

variable {B}

/-- The fstProjection morphism from `‚àë b : B, X ^ (E b)` to `B` again. -/
def fstProj (P : UvPoly E B) (X : C) : P @ X ‚ü∂ B :=
  ((Over.star E ‚ãô pushforward P.p).obj X).hom

@[reassoc (attr := simp)]
lemma map_fstProj {X Y : C} (P : UvPoly E B) (f : X ‚ü∂ Y) :
    P.functor.map f ‚â´ P.fstProj Y = P.fstProj X := by
  simp [fstProj, functor]

/-- A vertical map `œÅ : P.p ‚ü∂ Q.p` of polynomials (i.e. a commutative triangle)
```
    œÅ
E ----> F
 \     /
  \   /
   \ /
    B
```
induces a natural transformation `Q.functor ‚ü∂ P.functor ` obtained by pasting the following 2-cells
```
              Q.p
C --- >  C/F ----> C/B -----> C
|         |          |        |
|   ‚Üô     | œÅ*  ‚âÖ    |   =    |
|         v          v        |
C --- >  C/E ---->  C/B ----> C
              P.p
```
-/
def verticalNatTrans {F : C} (P : UvPoly E B) (Q : UvPoly F B) (œÅ : E ‚ü∂ F) (h : P.p = œÅ ‚â´ Q.p) :
    Q.functor ‚ü∂ P.functor := by
  have sq : CommSq œÅ P.p Q.p (ùüô _) := by simp [h]
  let cellLeft := (Over.starPullbackIsoStar œÅ).hom
  let cellMid := (pushforwardPullbackTwoSquare œÅ P.p Q.p (ùüô _) sq)
  let cellLeftMidPasted := TwoSquare.whiskerRight (cellLeft ‚â´‚Çï cellMid) (Over.pullbackId).inv
  simpa using (cellLeftMidPasted ‚â´‚Çï (vId (forget B)))

/-- A cartesian map of polynomials
```
           P.p
      E -------->  B
      |            |
   œÜ  |            | Œ¥
      v            v
      F -------->  D
           Q.p
```
induces a natural transformation between their associated functors obtained by pasting the following
2-cells
```
              Q.p
C --- >  C/F ----> C/D -----> C
|         |          |        |
|   ‚Üó     | œÜ*  ‚âÖ    | Œ¥* ‚Üó   |
|         v          v        |
C --- >  C/E ---->  C/B ----> C
              P.p
```
-/
def cartesianNatTrans {D F : C} (P : UvPoly E B) (Q : UvPoly F D)
    (Œ¥ : B ‚ü∂ D) (œÜ : E ‚ü∂ F) (pb : IsPullback P.p œÜ Œ¥ Q.p) : P.functor ‚ü∂ Q.functor :=
  let cellLeft : TwoSquare (ùü≠ C) (Over.star F) (Over.star E) (pullback œÜ) :=
    (Over.starPullbackIsoStar œÜ).inv
  let cellMid :  TwoSquare (pullback œÜ) (pushforward Q.p) (pushforward P.p) (pullback Œ¥) :=
    (pushforwardPullbackIsoSquare pb.flip).inv
  let cellRight : TwoSquare (pullback Œ¥) (forget D) (forget B) (ùü≠ C) :=
    pullbackForgetTwoSquare Œ¥
  let := cellLeft ‚â´·µ• cellMid ‚â´·µ• cellRight
  this

open NatTrans in
theorem isCartesian_cartesianNatTrans {D F : C} (P : UvPoly E B) (Q : UvPoly F D)
    (Œ¥ : B ‚ü∂ D) (œÜ : E ‚ü∂ F) (pb : IsPullback P.p œÜ Œ¥ Q.p) :
    NatTrans.IsCartesian (cartesianNatTrans P Q Œ¥ œÜ pb) :=
  (isCartesian_of_isIso _).vComp <|
  (isCartesian_of_isIso _).vComp <|
  isCartesian_pullbackForgetTwoSquare _

/-- A morphism from a polynomial `P` to a polynomial `Q` is a pair of morphisms `e : E ‚ü∂ E'`
and `b : B ‚ü∂ B'` such that the diagram
```
      E -- P.p ->  B
      ^            |
   œÅ  |            |
      |     œà      |
      Pb --------> B
      |            |
   œÜ  |            | Œ¥
      v            v
      F -- Q.p ->  D
```
is a pullback square. -/
structure Hom {F D : C} (P : UvPoly E B) (Q : UvPoly F D) where
  Pb : C
  Œ¥ : B ‚ü∂ D
  œÜ : Pb ‚ü∂ F
  œà : Pb ‚ü∂ B
  œÅ : Pb ‚ü∂ E
  is_pb : IsPullback œà œÜ Œ¥ Q.p
  w : œÅ ‚â´ P.p = œà

namespace Hom

open IsPullback

/-- The identity morphism in the category of polynomials. -/
def id (P : UvPoly E B) : Hom P P := ‚ü®E, ùüô B, ùüô _ , P.p , ùüô _, IsPullback.of_id_snd, by simp‚ü©

-- def vertCartExchange

/-- The composition of morphisms in the category of polynomials. -/
def comp {E B F D N M : C} {P : UvPoly E B} {Q : UvPoly F D} {R : UvPoly N M}
    (f : Hom P Q) (g : Hom Q R) : Hom P R := sorry

end Hom

variable (C) in
/-- Bundling up the the polynomials over different bases to form the underlying type of the
category of polynomials. -/
structure Total where
  {E B : C}
  (poly : UvPoly E B)

def Total.of (P : UvPoly E B) : Total C := Total.mk P

end UvPoly

open UvPoly

/-- The category of polynomial functors in a single variable. -/
instance : Category (UvPoly.Total C) where
  Hom P Q := UvPoly.Hom P.poly Q.poly
  id P := UvPoly.Hom.id P.poly
  comp := UvPoly.Hom.comp
  id_comp := by
    simp [UvPoly.Hom.comp]
    sorry
  comp_id := by
    simp [UvPoly.Hom.comp]
    sorry
  assoc := by
    simp [UvPoly.Hom.comp]

def Total.ofHom {E' B' : C} (P : UvPoly E B) (Q : UvPoly E' B') (Œ± : P.Hom Q) :
    Total.of P ‚ü∂ Total.of Q := sorry

namespace UvPoly

variable [HasTerminal C]

instance : SMul C (Total C) where
  smul S P := Total.of (smul S P.poly)

/-- Scaling a polynomial `P` by an object `S` is isomorphic to the product of `const S` and the
polynomial `P`. -/
@[simps!]
def smul_eq_prod_const [HasBinaryCoproducts C] [HasInitial C] (S : C) (P : Total C) :
    S ‚Ä¢ P ‚âÖ Total.of ((const S).prod P.poly) where
  hom := sorry
  inv := sorry
  hom_inv_id := sorry
  inv_hom_id := sorry

variable {E B : C}

namespace PartialProduct

open PartialProduct

/-- The counit of the adjunction `pullback P.p ‚ä£ pushforward P.p` evaluated `(star E).obj X`. -/
def Œµ (P : UvPoly E B) (X : C) : pullback (P.fstProj X) P.p ‚ü∂ E ‚®Ø X :=
  ((ev P.p).app ((star E).obj X)).left

/-- The partial product fan associated to a polynomial `P : UvPoly E B` and an object `X : C`. -/
@[simps -isSimp]
def fan (P : UvPoly E B) (X : C) : Fan P.p X where
  pt := P @ X
  fst := P.fstProj X
  snd := Œµ P X ‚â´ prod.snd -- ((forgetAdjStar E).counit).app X

attribute [simp] fan_pt fan_fst

/--
`P.PartialProduct.fan` is in fact a limit fan; this provides the univeral mapping property of the
polynomial functor.
-/
def isLimitFan (P : UvPoly E B) (X : C) : IsLimit (fan P X) where
  lift c := (pushforwardCurry <| overPullbackToStar c.fst c.snd).left
  fac_left := by aesop_cat (add norm fstProj)
  fac_right := by
    intro c
    simp only [fan_snd, pullbackMap, Œµ, ev, ‚Üê assoc, ‚Üê comp_left]
    simp_rw [homMk_eta]
    erw [‚Üê homEquiv_counit]
    simp [‚Üê ExponentiableMorphism.homEquiv_apply_eq, overPullbackToStar_prod_snd]
  uniq := by
    intro c m h_left h_right
    dsimp [pushforwardCurry]
    symm
    rw [‚Üê homMk_left m (U := Over.mk c.fst) (V := Over.mk (P.fstProj X))]
    congr 1
    apply (Adjunction.homEquiv_apply_eq (adj P.p) (overPullbackToStar c.fst c.snd) (Over.homMk m)).mpr
    simp [overPullbackToStar, Fan.overPullbackToStar, Fan.over]
    apply (Adjunction.homEquiv_apply_eq _ _ _).mpr
    rw [‚Üê h_right]
    simp [forgetAdjStar, comp_homEquiv, Comonad.adj]
    simp [Equivalence.toAdjunction, homEquiv]
    simp [coalgebraEquivOver, Equivalence.symm]; rfl

end PartialProduct

open PartialProduct

/-- Morphisms `b : Œì ‚ü∂ B` and `e : pullback b P.p ‚ü∂ X` induce a morphism `Œì ‚ü∂ P @ X` which is the
lift of the partial product fan. -/
-- used to be called `pairPoly`
abbrev lift {Œì X : C} (P : UvPoly E B) (b : Œì ‚ü∂ B) (e : pullback b P.p ‚ü∂ X) :
    Œì ‚ü∂ P @ X :=
  partialProd.lift ‚ü®fan P X, isLimitFan P X‚ü© b e

@[simp]
theorem lift_fst {Œì X : C} {P : UvPoly E B} {b : Œì ‚ü∂ B} {e : pullback b P.p ‚ü∂ X} :
    P.lift b e ‚â´ P.fstProj X = b := partialProd.lift_fst ..

@[reassoc]
theorem lift_snd {Œì X : C} {P : UvPoly E B} {b : Œì ‚ü∂ B} {e : pullback b P.p ‚ü∂ X} :
    comparison (c := fan P X) (P.lift b e) ‚â´ (fan P X).snd =
    (pullback.congrHom (partialProd.lift_fst b e) rfl).hom ‚â´ e := partialProd.lift_snd ..

theorem hom_ext {Œì X : C} {P : UvPoly E B} {f g : Œì ‚ü∂ P @ X}
    (h‚ÇÅ : f ‚â´ P.fstProj X = g ‚â´ P.fstProj X)
    (h‚ÇÇ : comparison f ‚â´ (fan P X).snd =
      (pullback.congrHom (by exact h‚ÇÅ) rfl).hom ‚â´ comparison g ‚â´ (fan P X).snd) :
    f = g := partialProd.hom_ext ‚ü®fan P X, isLimitFan P X‚ü© h‚ÇÅ h‚ÇÇ

/-- A morphism `f : Œì ‚ü∂ P @ X` projects to a morphism `b : Œì ‚ü∂ B` and a morphism
`e : pullback b P.p ‚ü∂ X`. -/
-- formerly `polyPair`
def proj {Œì X : C} (P : UvPoly E B) (f : Œì ‚ü∂ P @ X) :
    Œ£ b : Œì ‚ü∂ B, pullback b P.p ‚ü∂ X :=
  ‚ü®fan P X |>.extend f |>.fst, fan P X |>.extend f |>.snd‚ü©

@[simp]
theorem proj_fst {Œì X : C} {P : UvPoly E B} {f : Œì ‚ü∂ P @ X} :
    (proj P f).fst = f ‚â´ P.fstProj X := rfl

/-- The second component of `proj` is a comparison map of pullbacks composed with `Œµ P X ‚â´ prod.snd` -/
-- formerly `polyPair_snd_eq_comp_u‚ÇÇ'`
@[simp]
theorem proj_snd {Œì X : C} {P : UvPoly E B} {f : Œì ‚ü∂ P @ X} :
    (proj P f).snd = pullback.map _ _ _ _ f (ùüô E) (ùüô B) (by simp) (by simp) ‚â´ (fan P X).snd := by
  simp [proj]

/-- The domain of the composition of two polynomials. See `UvPoly.comp`. -/
def compDom {E B D A : C} (P : UvPoly E B) (Q : UvPoly D A) :=
  Limits.pullback Q.p (fan P A).snd

@[simps!]
def comp {E B D A : C} (P : UvPoly E B) (Q : UvPoly D A) : UvPoly (compDom P Q) (P @ A) := by
  letI p := pullback.snd Q.p (fan P A).snd ‚â´ pullback.fst (fan P A).fst P.p
  refine { p, exp.exists_rightAdjoint := ?_ }
  let F1 := map (P.fstProj A) ‚ãô Over.pullback P.p
  let G1 := pushforward P.p ‚ãô Over.pullback (P.fstProj A)
  let adj1 : F1 ‚ä£ G1 := mapPullbackAdj (P.fstProj A) |>.comp (adj P.p)
  let F2 := Over.pullback (pullback.fst (fan P A).fst P.p)
  let G2 := map (pullback.snd (fan P A).fst P.p)
  let F3 := map (fan P A).snd ‚ãô Over.pullback Q.p
  let G3 := pushforward Q.p ‚ãô Over.pullback (fan P A).snd
  let adj2 : F3 ‚ä£ G3 := mapPullbackAdj (fan P A).snd |>.comp (adj Q.p)
  let G4 := map (pullback.fst Q.p (fan P A).snd)
  let F5 := map p
  let G5 := Over.pullback p
  let adj3 : F5 ‚ä£ G5 := mapPullbackAdj p
  suffices G5 ‚ä£ G4 ‚ãô G3 ‚ãô G2 ‚ãô G1 from ‚ü®_, ‚ü®this‚ü©‚ü©
  refine {
    unit := {
      app Y := ?_
      naturality := sorry
    }
    counit := {
      app X := ?_
      naturality := ?_
    }
    left_triangle_components := sorry
    right_triangle_components := sorry
  }
  ¬∑
    change Y ‚ü∂ (G5 ‚ãô G4 ‚ãô G3 ‚ãô G2 ‚ãô G1).obj Y
    refine adj1.homEquiv _ _ ?_
    let f : F1.obj Y ‚ü∂ (F2 ‚ãô G2).obj Y :=
      Over.homMk (pullback.lift (pullback.fst ..)
        (pullback.lift (pullback.fst .. ‚â´ Y.hom) (pullback.snd ..)
          ?_) ?_) ?_
    refine f ‚â´ G2.map ?_
    refine adj2.homEquiv _ _ ?_
    refine ?_ ‚â´ G4.map (adj3.homEquiv (G5.obj Y) _ (Over.homMk (pullback.fst ..) ?_))
    refine Over.homMk (pullback.lift
      (pullback.fst .. ‚â´ pullback.fst ..)
      (pullback.lift (pullback.snd ..)
        (pullback.fst .. ‚â´ pullback.snd ..) ?_)
      ?_) ?_
    ¬∑ simp [‚Üê pullback.condition, F2]
    ¬∑ simp only [assoc, pullback.condition, limit.lift_œÄ_assoc, PullbackCone.mk_œÄ_app, p]
    ¬∑ simp only [F3, F2, G4, G5, map_obj_hom, pullback_obj_hom, comp_obj]
      rw [pullback.lift_snd_assoc, pullback.lift_fst]
    ¬∑ rw [pullback.condition]; rfl
    ¬∑ rw [‚Üê pullback.condition, assoc]; rfl
    ¬∑ rw [pullback.lift_fst]
    ¬∑ simp only [F2, G2, comp_obj, map_obj_hom, pullback_obj_hom]
      rw [pullback.lift_snd_assoc, pullback.lift_snd]; rfl
  dsimp

  done
    -- simp
    -- simp only [comp_obj, map_obj_hom, id_obj,
    --   const_obj_obj, pullback_obj_hom, limit.lift_œÄ_assoc, PullbackCone.mk_pt, cospan_right,
    --   PullbackCone.mk_œÄ_app, limit.lift_œÄ, F3, F2, G4, G5]

  -- ¬∑ simp [pullback.condition, F5, G5]
  ¬∑
        dsimp -- [G1,G2,G3,G4,G5]
        have f X : G5.obj X ‚ü∂ F1.obj X :=
          _
        refine adj1.counit
        have := _ ‚â´ @(adj P.p).counit.app _ ‚â´ _; simp at this
        refine ((mapPullbackAdj _).homEquiv _ _).symm ?_

        done

/-- The associated functor of the composition of two polynomials is isomorphic to the composition of the associated functors. -/
def compFunctorIso [HasPullbacks C] [HasTerminal C]
    {E B D C : C} (P : UvPoly E B) (Q : UvPoly D C) :
    P.functor ‚ãô Q.functor ‚âÖ (comp P Q).functor := by
  sorry

instance monoidal [HasPullbacks C] [HasTerminal C] : MonoidalCategory (UvPoly.Total C) where
  tensorObj X Y := ‚ü®comp X.poly Y.poly‚ü©
  whiskerLeft X Y‚ÇÅ Y‚ÇÇ := sorry
  whiskerRight := sorry
  tensorUnit := sorry
  associator := sorry
  leftUnitor := sorry
  rightUnitor := sorry

#print sorries UvPoly.comp UvPoly.PartialProduct.isLimitFan partialProd.lift_snd partialProd.hom_ext
end UvPoly
end CategoryTheory
end
